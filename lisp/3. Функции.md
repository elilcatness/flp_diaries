###### Безымянные функции

*lambda* - определение функции

`(lambda (аргументы) тело)`

Например, `(lambda (x) (* x x))` - функция возведения в квадрат

<hr>

###### Именованные функции

```lisp
(defun function-name (arguments...) "optional-documentation..." (interactive-argument-passing-info) optional body...)
```

Например.

```lisp
(defun sqr (x) (* x x))
```

– именованная функция `sqr` для возведения в квадрат

`(sqr 5) -> 25`

Пример №2.

```lisp
(defun mul (x y) (* x y))
```

###### Некоторые полезные операторы

- **операторы сравнения**
	- **eq**
		Возвращает истину, если все аргументы равны. Работает только с [[1. Типы данных и переменные|атомами]] и целыми числами.
	- **eql**
		Сравнение вещественных чисел.
	- **equal**
		Работа со [[2. Списки|списками]].
	- **equalp**
		Может сравнивать объекты заранее не определённой структуры.
	- **atom**
		Возвращает `T`, если её аргумент является атомом, и `nil` в противном случае.
- **логические функции**

	- **not**
		Возвращает `T`, если аргумент является `nil`, иначе `nil`.
	- **null**
		Возвращает `T`, если аргумент является ложью, иначе `nil`.
	
	Хотя на самом деле они синонимичны.
- **константы**
	- T – логическая истина
	- nil – логическая ложь ([[2. Списки|пустой список]])
- **операторы условия**
	- [[#cond]]
- **Поток вычислений**
	- progn – позволяет несколько команд определить в стиле императивного программирования

<hr>

###### cond

```lisp
(cond
	(условие значение)
	(условие значение)
	(условие значение)
	...
	(T значение)
)
```

`(T значение)` – хороший тон, дабы возвращалось значение по умолчанию, если ни одно условие не выполнилось.

**Пример.**

```lisp
(defun sign (x) (cond
    ((> x 0) 1)
    ((< x 0) -1)
    (T 0)
))

(print (sign 10)) ; output: 1
```

<hr>

###### progn

```lisp
(progn 
	оператор1
	оператор2
	...
)
```

`progn` выполняет операторы по одному. Такой стиль программирования не характерен для LISP. Однако может нередко использоваться.

- `progn` возвращает результат последнего оператора;
- `prog1` возвращает результат первого оператора;
- `prog2` возвращает результат второго оператора;
- и т. д.

**Пример.**

```lisp
(progn 1 2 3 4 5 6) ; вернёт 6
(prog1 1 2 3 4 5 6) ; вернёт 1
(prog2 1 2 3 4 5 (sign 5)) ; вернёт 2
(progn 1 2 3 4 5 (sign 5)) ; вернёт 1
```