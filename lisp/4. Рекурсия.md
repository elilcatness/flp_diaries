[[3. Функции]]

- **Простая**
	Один рекурсивный вызов, предпочтительно в последнем операторе (*хвостовая рекурсия*)
- **Параллельная**
	Несколько рекурсивных вызовов в аргументах одного из операторов
- **Взаимная**
	Две функции вызывают друг друга
- **Рекурсия более высокого порядка**
	Функция Аккермена

Для отлаживания рекурсии в LISP существуют команды:

- `(trace function-name)` – включить трассировку функции под названием `function-name`
- `(untrace function-name)` – отключить трассировку функции под названием `function-name`

Использование <span style="color:red"><b>циклов</b></span> в LISP <span style="color:red">не является хорошей практикой</span>. Вместо них [[5. Рекурсивная обработка списков|пользуются рекурсией]].

###### Факториал

$$x!= \begin{cases} 1,\space x=0\\x \cdot (x-1)!,\space x>0 \end{cases}$$

```lisp
(defun f (x)
	(cond
		((eq x 0) 1)
		((< x 0) 0)
		(T (* x (f (- x 1))))
	)
)
```

<hr>

###### Числа Фибоначчи

$$f(x)=\begin{cases} 1,\space x=1\\1,\space x=2\\f(x-1)+f(x-2),\space x > 2 \end{cases}$$

```lisp
(defun fib (x)
	(cond
		((<= x 0) 0)
		((eq x 1) 1)
		((eq x 2) 1)
		(T (+ (fib (- x 1)) (fib (- x 2))))
	)
)
```

При выполнении данного алгоритма для нахождения, например, 100-го числа Фибоначчи возникает так называемый *комбинаторный взрыв*.

*Комбинаторный взрыв* – это неконтролируемый рост вычислительной сложности алгоритма при изменении его данных.
###### Числа Фибоначчи (без комбинаторного взрыва)

```lisp
(defun fib (x &optional y)
	(cond
		((<= x 0) 0)
		((null y) (car (fib x T)))
		((eq x 1) '(1 0))
		((eq x 2) '(1 1))
		(T (fibservice (fib (- x 1) T))) 
	)
)
(defun fibservice (lst)
	(cons
		(+ (car lst) (cadr lst))
		(cons (car lst) nil))
)
```

`&optional y` значит, что параметр `y` – необязательный.

`(null y)` – проверка на то, является ли `y` ложью.