![[Pasted image 20240608152850.png]]

![[Pasted image 20240608152935.png]]

![[Pasted image 20240608153312.png]]

![[Pasted image 20240608153423.png]]

![[Pasted image 20240608153525.png]]

![[Pasted image 20240608153747.png]]

**ЧИСЛА НУЖНО СРАВНИВАТЬ С ПОМОЩЬЮ =**

![[Pasted image 20240608153854.png]]

![[Pasted image 20240608153927.png|300]]

![[Pasted image 20240608154411.png|500]]

Функция `let/let*` имеет раздел инициализации, в которой можно определить локальные данной функции переменные - они пропадут после вычисления функции.

`let` - инициализация может происходить параллельно. Не может ссылаться на предыдущие инициализированные переменные. Предпочтительнее, чем `let*`, так как при его вычислении могут использоваться [[1. Введение#^c8f747|ленивые вычисления]] и параллельные вычисления.
`let*` - инициализация должна выполняться строго последовательно. Может ссылаться на предыдущие инициализированные переменные.

Результат последней формы является результатом всей команды `let/let*`, что похоже на `progn`.

![[Pasted image 20240608174009.png]]

`if (условие значение-при-истинности)` - при лжи возвращается `nil`.

`when` - `if` с неявным `progn`: если условие истинно, формы вычисляются, результатом является результат последней формы; иначе - `nil`.
`unless`: если условие ложно, формы вычисляются, результатом является результат последней формы; иначе - `nil`.

![[Pasted image 20240608180241.png|500]]

![[Pasted image 20240608180628.png|500]]

![[Pasted image 20240608182808.png|500]]

##### Операторы определения функций

![[Pasted image 20240608182857.png|500]]

![[Pasted image 20240608183209.png|500]]

**Пример на `&optional`**:

![[Pasted image 20240608183317.png|500]]

**Пример на `&rest`:**

```lisp
((lambda (&optional x &rest y) y) 1 2 3 4) ; (2 3 4)
```

**Пример на `&key`:**

```lisp
((lambda (&key x y) (- x y)) :y 5 :x 7) ; 2
```

**Пример на `&aux`:**

```lisp
(lambda (&aux (x 5) x)) ; 5
```


<hr>

![[Pasted image 20240608183928.png|500]]

![[Pasted image 20240608184002.png|500]]

