![[Pasted image 20240608122145.png]]

**Тезис Тьюринга:** любой алгоритм можно вычислить с помощью Машины Тьюринга.

![[Pasted image 20240608122208.png]]

**Тезис Черча-Тьюринга:** любой алгоритм можно вычислить как с помощью Машины Тьюринга, так и с помощью частично-рекурсивных функций.

**Лямбда-исчисление**

- **Термы**
	- Переменная `t` является термом
	- Конструкция вида `λx.t` является термами, если `t` - терм, а `x` - переменная
	- Конструкция вида `M N` является термом, если `M` и `N` - термы (аппликация)
- **Абстракция функций**
	- Например, `f(x,y)=x*y` может быть представлено как `λx.λy.(x*y)`
- **Альфа-редукция:** `λx.f(x)` --> `λy.(y*y)` (*переименование*)
	- Например, `λx.(x*x)` --> `λy.(y*y)`
	- Может использоваться, если в большом выражении при преобразовании оказываются две разные функции, имеющие одинаковые названия переменных, что, в свою очередь, приводит к наделению переменной нового смысла (что не было изначально запланировано).
- **Свободные и связанные переменные**
	- Например, `λx.(x*y)`, где `x` - связанная переменная, `y` - свободная переменная
- **Бета-редукция:** `λx.f(x) M` --> `f(M)` (*подстановка*)
	- Например, `λx.(x*x) 5` --> `5 * 5`

![[Pasted image 20240608123524.png]]

Джон Маккарти придумал, что ИИ не должен пытаться повторить работу человеческого мозга, а вместо этого он должен базироваться на математических отношениях.

![[Pasted image 20240608123717.png]]

До появления транслятора транслирование производилось лаборантами вручную, что привело к следующему наследию: в языке LISP существует несколько функций, делающих одно и то же, от разных аргументов. Связано это с ручной трансляцией кода LISP в Assembler.

LISP - первый язык программирования, чей транслятор написан на нём же.

##### Чистое функциональное программирование

Функциональное программирование предполагает, что программа представляется в виде одной большой функции, и эта функция вычисляется, что представляет собой выполнение программы.

- **Понятие чистоты языка**
	Такое ФП, при котором все используемые функции имеют только входные параметры и выходные результаты, то есть *у функции нет никакого побочного действия.*
	Пример функции с побочным действием: функция присвоения.
	В качестве результата: изменение состояния памяти.
- **Ленивые вычисления**
	Ленивые вычисления предполагают, что мы что-то вычисляем только в том, что оно нам действительно понадобилось. Если программа имеет функции с побочным действием, приходится вычислять всё. ^c8f747
- **Ограничения чисто функционального программирования**
	Существуют классы задач, которые не могут быть представлены в виде чистого функционального программирования. Например, задачи ввода/вывода.

Программы, написанные в функциональном стиле, легко вычислять параллельно. Функция представляется в виде дерева, и её листья можно вычислять одновременно. Однако это возможно только в том случае, если вычисления являются независимыми.
Если вычисления зависимы друг от друга, то ничего не остаётся, кроме как в соответствии с этими зависимости вычислять их строго друг за другом.

##### Основные конструкции языка

![[Pasted image 20240608125735.png]]

![[Pasted image 20240608133920.png]]

![[Pasted image 20240608134125.png]]

`(A . B)` - точечная пара. Получается в случае, если не удалось объединить в список `A` и `B`. Сигнализирует об ошибке.

![[Pasted image 20240608134423.png]]

Лучше ими не пользоваться.

`setq` подавляет вычисление первого аргумента.

С помощью функции `setf` можно получить ссылку на элемент какой-то структуры и её поменять.

Пример:

```lisp
(set 'l '(a b c))
(print l) ; (A B C)
(print (nth 1 l)) ; B
(setf (nth 1 l) 'd)
(print l) ; (A D C)
```

**Ячейка памяти**

![[Pasted image 20240608135109.png]]

![[Pasted image 20240608135124.png]]

![[Pasted image 20240608135203.png|300]]

![[Pasted image 20240608135346.png]]

![[Pasted image 20240608135420.png]]

![[Pasted image 20240608135532.png]]

![[Pasted image 20240608135625.png]]

![[Pasted image 20240608135731.png]]

![[Pasted image 20240608140003.png]]





