##### Функции высшего порядка (функционалы)

![[Pasted image 20240609094351.png|500]]

![[Pasted image 20240609094537.png|500]]

![[Pasted image 20240609094915.png|500]]

![[Pasted image 20240609095117.png|500]]

![[Pasted image 20240609095156.png|500]]

![[Pasted image 20240609095410.png|500]]

![[Pasted image 20240609095558.png|500]]

![[Pasted image 20240609095952.png|500]]

![[Pasted image 20240609100157.png|500]]

![[Pasted image 20240609101252.png|500]]

Падает, если в списке есть повторяющиеся элементы.

##### Макросы

![[Pasted image 20240609101622.png|500]]

Макросы не вычисляют свои аргументы.

![[Pasted image 20240609101724.png|500]]

![[Pasted image 20240609101852.png|500]]

В коде есть ошибка.

![[Pasted image 20240609102227.png|500]]

`&whole` - аргумент, который макрос получает в самом начале.
Пример:

```lisp
(defmacro frst (&whole call arg) (rplaca call 'car))
(macroexpand '(frst '(a b c))) ; (CAR '(A B C))
```

![[Pasted image 20240609120034.png|500]]

**Пример 1.**

```lisp
`(A ,(+ 2 2) 3) ; (A 4 3)
```

- Обратный апостроф говорит о том, что начался макрос.
- `A` не вычисляется, потому что про него ничего не сказано.
- `,` указывает на то, что `(+ 2 2)` нужно вычислить.
- `3`, как и `A`, не вычислится.

**Пример 2.**

```lisp
(setq a '(b c))
`(A ,@A 3) ; (A B C 3)
; выражение без @
`(A ,A 3) ; (A (B C) 3)
```

- `@` распаковывает содержимое `A`